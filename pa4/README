README file for Programming Assignment 4 (C++ edition)
======================================================

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	Do not modify any other file.

Instructions
------------

	To compile your semantic analyzer program type:

	% make

	This produces an executable named "semant" which is standalone
	phase of the Cool compiler. The semantic analyzer executable
	accepts as input the output of the parser phase, so in order 
	to test it, you'll need to copy a lexer and a parser into the
	directory: either your own lexer and parser from the previous
	assignments, or the lexer and parser from the reference
	implementation of the compiler.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

    If you think your semantic checker is correct and behaves like
    the one we wrote, you can try it out by replacing the semantic
    checker in the reference compiler with your own lexer. Just copy
    your compiled semantic binary from this assignment into the
    directory where the reference compiler is.

    To submit your solution, run:

    % make zip

    Check the resulting zip file to make sure it contains everything
    it should. Then submit it on Gradescope.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

1. Explain design decisions, explain why your code is correct, and
	why your test cases are adequate.

Author: hang yu 
NetID: hy1746
//////////////////////////////////////////////////////////////////////
///						OVERVIEW
//////////////////////////////////////////////////////////////////////

My semantic analyser runs as the descripions below:

Step 1. It constructs the inheritance graph, which in implemented by a global Symbol
table and firstly check whether the class is well defined. Also, the first step 
is to fill the classtable class, which needs to traverse all the classes in the
AST. In this step, the analyser should install basic classes and basic methods.

Step 2. FIRST PASS: Inorder tranverse the AST to down to the featrues (including 
attributes and methods) and construct method symboltable and vairable symboltable
for each class. During this process, the analyser should do facial type checking,
such as usage of SELF_TYPE and the validity of some user-defined type.

Step 3. Validate Main class and main method. This needs to be done exactly in step
2 because we need to access all the class to check inheritance of Main class and 
need to prevent main method inherit from parent classes (which is prohibited).

Step 4. Inherit methods and features from parents. During the inheritance, method is
permitted to be inherited from parent class but attribute is not. The analyser also
need to check override and inheritance to basic class and basic methods.

Step 5. SECOND PASS: Inorder tranverse the AST again. This time the analyer should 
check the validity of each expression recursively and whether actually expression 
type conform the declared type.

//////////////////////////////////////////////////////////////////////
///						Inheritance
//////////////////////////////////////////////////////////////////////

The analyser go through the AST to generate edges of inheritance relationship.
The information of inheritance is stored in `class_tab` symboltable, a hashmap.
That is to say, one class could recursively get its parent from the symboltable
until it reaches the Object.

The logic of implementation can be seen from function 'inherit_features()', which 
fully runs the responsibility of step 4. This function servers two part of classes.
1. For basic classes, it installs basic features from Object class.
2. For user-defined classes, it installs valid method inherited from its direct parent
cascading to the Object. And it also does validity checking during process, which includes:
	1) whether a cycle exists in a inheritance graph.
	2) whether an attribute is overwriten
	3) whether a builtin class is illegally inherited
	4) whether a builtin method is illegally overwriten
	5) whether a class inherit a non-defined class
	6) during overriding a function, whether the number and types of new formals conform the old formals

//////////////////////////////////////////////////////////////////////
///					vairable table and method table
//////////////////////////////////////////////////////////////////////

In my design, the symboltable of all class is global, and each class maintains 
its own variable table and method table. In some special case, case table might
appear to deal with branches.

Respecting the scope issue. It would be much clear to enter the scope only when
necessary. Every time the analyser meets with a let expression or a method definition
(formals), it enter a new scope for variable table. When meets a case, it create a 
casetable to contains case identifiers. When using variable table, the analyser use
lookup() to index the symbol. probe() is only used when it nees to check duplicate of 
formal definition.

//////////////////////////////////////////////////////////////////////
///					Type Checking
//////////////////////////////////////////////////////////////////////

Type checking is much more complex than expected. The analyser is implemented iteratively
to fulfill all the requirements. The first few iterations deals about everything but 
SELF_TYPE. Then the last few iterations take SELF_TYPE into considertaion and try to 
catch each invalid case about SELF_TYPE. 

The implementation of type checking consists of two parts: One regarding classtable and 
one regarding expression. The classtable one deals with type check of classes, attributes, 
methods and formals, and the code is derictly from classtable. Then when reference to expression
type, the analyser use the pure virtual function semant_Expression and its implementation under
each expression subclass to do semant analysis.

Some very helpful type check function is abstracted, like 'is_subclass' and 'lca'.

//////////////////////////////////////////////////////////////////////
///						Error reporting
//////////////////////////////////////////////////////////////////////

Type checking in the classtable class could access semant_error() at any time.
However expression subclass cannot access the semant_error(). Thus, the analyser 
has two global variable: `current_class` (which indicates the real representaion of
SELF_TYPE) and `sc` (which indicates the classtable so that expressions can report error).

//////////////////////////////////////////////////////////////////////
///						Good Test Case 
//////////////////////////////////////////////////////////////////////

Actually there are plenty of cool source code under the folder of examples. Thus I use ALL 
the cool source code given from example folder to serve as good test case. 

Additionaly, most of good test case would be modify with one intentional error to serve 
as bad test cases.

//////////////////////////////////////////////////////////////////////
///						Bad Test Case 
//////////////////////////////////////////////////////////////////////

My bad.cl may be messy but adequate. It tests the follow aspects:

1. Inheritance (which descibed in inheritance part before)
2. Main validity (which descibed in part 1)
3. Most of things about SELF_TYPE and self 
	1) SELF_TYPE class inherited
	2) self assigned as attribute 
	3) SELF_TYPE as formal declared type
4. Attribute
	1) expression type conform declared type 
	2) identifier validity 
5. Method
	1) body expression type conform return type
	2) Formal type validity
6. Expression 
	1) illegal operand type 
	2) type not defined 
	3) type not conform
etc.
